-- phpMyAdmin SQL Dump
-- version 4.5.1
-- http://www.phpmyadmin.net
--
-- Host: 127.0.0.1
-- Generation Time: Feb 06, 2017 at 11:29 AM
-- Server version: 10.1.19-MariaDB
-- PHP Version: 7.0.13

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `code_e_salsa`
--
/*CREATE DATABASE IF NOT EXISTS `code_e_salsa` DEFAULT CHARACTER SET latin1 COLLATE latin1_swedish_ci;
USE `code_e_salsa`; */

-- --------------------------------------------------------

--
-- Table structure for table `easy`
--

CREATE TABLE `easy` (
  `id` tinyint(11) NOT NULL,
  `question` text NOT NULL,
  `option1` text NOT NULL,
  `option2` text NOT NULL,
  `option3` text NOT NULL,
  `option4` text NOT NULL,
  `answer` char(1) NOT NULL,
  `hint` text NOT NULL,
  `wrong1` char(1) NOT NULL,
  `wrong2` char(1) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `easy`
--

INSERT INTO `easy` (`id`, `question`, `option1`, `option2`, `option3`, `option4`, `answer`, `hint`, `wrong1`, `wrong2`) VALUES
(1, '#include<iostream>\n \nusing namespace std;\nclass Base1 {\n public:\n     Base1()\n     { cout << " Base1 s constructor called" << endl;  }\n};\n \nclass Base2 {\n public:\n     Base2()\n     { cout << "Base2 s constructor called" << endl;  }\n};\n \nclass Derived: public Base1, public Base2 {\n   public:\n     Derived()\n     {  cout << "Derived s constructor called" << endl;  }\n};\n \nint main()\n{\n   Derived d;\n   return 0;\n}\n\n'' \n" '' "', 'Base2â€™s constructor called\r\nBase1â€™s constructor called\r\nDerivedâ€™s constructor called', 'Base1â€™s constructor called\r\nBase2â€™s constructor called', 'Derivedâ€™s constructor called\r\nBase1â€™s constructor called\r\nBase2â€™s constructor called', 'Base1â€™s constructor called\r\nBase2â€™s constructor called\r\nDerivedâ€™s constructor called', 'D', 'In case of Multiple Inheritance,  constructors of base classes  are always called in derivation  order from left to right and  Destructors are called in reverse  Order.', 'A', 'C'),
(2, '//Assume integer takes 4 bytes\r\n#include<iostream>\r\nusing namespace std;\r\n \r\nclass base {\r\n    int arr[10];     \r\n};\r\n \r\nclass b1: public base { };\r\n \r\nclass b2: public base { };\r\n \r\nclass derived: public b1, public b2 {};\r\n \r\nint main(void)\r\n{ \r\n  cout<<sizeof(derived);\r\n  getchar();\r\n  return 0;\r\n}', '40', '80', '160', '120', 'B', 'Since b1 and b2 both inherit from class base, two copies of class base are there in class derived. This kind of inheritance without virtual causes wastage of space and ambiguities. virtual base classes are used to save space and avoid ambiguities in such cases', 'C', 'D'),
(3, 'What is the output of following code?\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Test\r\n{\r\nprivate:\r\nint x;\r\nint y;\r\npublic:\r\nTest(int x = 0, int y = 0) { this->x = x; this->y = y; }\r\nvoid fun1() { cout << "Inside fun1()"; }\r\nvoid fun2() { cout << "Inside fun2()"; this->fun1(); }\r\n};\r\n\r\nint main()\r\n{\r\nTest obj;\r\nobj.fun2();\r\nreturn 0;\r\n}', 'Inside fun2()', 'Inside fun1()', 'Inside fun2()\r\nInsidefun1()', 'Compile Error', 'C', 'This pointer poins the calling object.', 'A', 'B'),
(4, 'Find the output of following program\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Test\r\n{\r\nprivate:\r\nint x;\r\nint y;\r\npublic:\r\nTest(int x = 0, int y = 0) { this->x = x; this->y = y; }\r\nvoid setX(int a) { x = a; }\r\nvoid setY(int b) { y = b; }\r\nvoid destroy() { delete this; }\r\nvoid print() { cout << "x = " << x << " y = " << y << endl; }\r\n};\r\n\r\nint main()\r\n{\r\nTest obj;\r\nobj.destroy();\r\nobj.print();\r\nreturn 0;\r\n}', 'x = 0  y = 0', 'x = Garbage  y = Garbage', 'Compile-time Error', 'Runtime error', 'D', 'Object cannot be displayed after destroyed.', 'A', 'B'),
(5, 'What is the output of following code?\r\n#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n   int x = -1;\r\n   try {\r\n      cout << "Inside try \n";\r\n      if (x < 0)\r\n      {\r\n         throw x;\r\n         cout << "After throw \n";\r\n      }\r\n   }\r\n   catch (int x ) {\r\n      cout << "Exception Caught \n";\r\n   }\r\n \r\n   cout << "After catch \n";\r\n   return 0;\r\n}', 'Inside try\r\nException Caught\r\nAfter throw \r\nAfter catch', 'Inside try\r\nException Caught\r\nAfter catch', 'Inside try\r\nException Caught', 'Inside try\r\nAfter throw\r\nAfter catch', 'B', 'When an exception is thrown, lines of try block after the throw statement are not executed. When exception is caught, the code after catch block is executed. Catch blocks are generally written at the end through.', 'C', 'D'),
(6, 'What is the difference between struct and class in C++?', 'All members of a structure are public and structures dont have constructors and destructors\r\n', 'Members of a class are private by default and members of struct are public by default. When deriving a struct from a class/struct, default access-specifier for a base class/struct is public and when deriving a class, default access specifier is private.\r\n', 'All members of a structure are public and structures dont have virtual functions\r\n', 'All of the above\r\n', 'B', 'when deriving a class, default access specifier is private.', 'A', 'D'),
(7, '#include <iostream>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\nint a;\r\n    try\r\n    {\r\n       throw  a ;\r\n    }\r\n    catch (int param)\r\n    {\r\n        cout << "int exception\n";\r\n    }\r\n    catch (...)\r\n    {\r\n        cout << "default exception\n";\r\n    }\r\n    cout << "After Exception";\r\n    return 0;\r\n}', 'default exception\r\nAfter Exception', 'int exception\r\nAfter Exception', 'int exception', 'default exception', 'D', 'The block catch(...) is used for catch all, when a data type of a thrown exception doesn t match with any other catch block, the code inside catch(...) is executed. Note here  a  is considered as a character and not as an integer.', 'A', 'C'),
(8, '#include <iostream>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n    try\r\n    {\r\n        try\r\n        {\r\n            throw 20;\r\n        }\r\n        catch (int n)\r\n        {\r\n            cout << "Inner Catch\n";\r\n            throw;\r\n        }\r\n    }\r\n    catch (int x)\r\n    {\r\n        cout << "Outer Catch\n";\r\n    }\r\n    return 0;\r\n}', 'Outer Catch', 'Inner Catch', 'Inner Catch\r\nOuter Catch', 'Compile Error', 'C', 'The statement  throw;  is used to re-throw an exception. This is useful when a function can handles some part of the exception handling and then delegates the remaining part to the caller. A catch block cleans up resources of its function, and then rethrows the exception for handling elsewhere.', 'A', 'B'),
(9, '#include<iostream>\r\nusing namespace std;\r\n \r\nclass Base\r\n{\r\npublic:\r\n    virtual void show() { cout<<" In Base \n"; }\r\n};\r\n \r\nclass Derived: public Base\r\n{\r\npublic:\r\n    void show() { cout<<"In Derived \n"; }\r\n};\r\n \r\nint main(void)\r\n{\r\n    Base *bp = new Derived;\r\n    bp->show();\r\n \r\n    Base &br = *bp;\r\n    br.show();\r\n \r\n    return 0;\r\n}', 'In Base \r\nIn Base', 'In Base \r\nIn Derived', 'In Derived\r\nIn Derived', 'In Derived\r\nIn Base', 'C', 'Since show() is virtual in base class, it is called according to the type of object being referred or pointed, rather than the type of pointer or reference.', 'A', 'D'),
(10, '#include<iostream>\r\nusing namespace std;\r\nclass Base  {\r\npublic:\r\n    Base()    { cout<<"Constructor: Base"<<endl; }\r\n    virtual ~Base()   { cout<<"Destructor : Base"<<endl; }\r\n};\r\nclass Derived: public Base {\r\npublic:\r\n    Derived()   { cout<<"Constructor: Derived"<<endl; }\r\n    ~Derived()  { cout<<"Destructor : Derived"<<endl; }\r\n};\r\nint main()  {\r\n    Base *Var = new Derived();\r\n    delete Var;\r\n    return 0;\r\n}', 'Constructor: Base\r\nConstructor: Derived\r\nDestructor : Derived\r\nDestructor : Base', 'Constructor: Base\r\nConstructor: Derived\r\nDestructor : Base', 'Constructor: Base\r\nConstructor: Derived\r\nDestructor : Derived', 'Constructor: Derived\r\nDestructor : Derived', 'A', 'Since the destructor is vitrual, the derived class destructor is called which in turn calls base class destructor.', 'C', 'D'),
(11, 'How to create a dynamic array of pointers (to integers) of size 10 using new in C++?', 'int *arr = new int *[10];', 'int **arr = new int *[10];', 'int **arr = new int [10];', 'Not Possible', 'B', 'Since array of pointers is to be created, pointer to a pointer will be required.', 'A', 'D'),
(12, '#include<iostream>\r\n  \r\nusing namespace std;\r\nclass Base1 {\r\n public:\r\n     Base1()\r\n     { cout << " Base1 s constructor called" << endl;  }\r\n};\r\n  \r\nclass Base2 {\r\n public:\r\n     Base2()\r\n     { cout << "Base2 s constructor called" << endl;  }\r\n};\r\n  \r\nclass Derived: public Base1, public Base2 {\r\n   public:\r\n     Derived()\r\n     {  cout << "Derived s constructor called" << endl;  }\r\n};\r\n  \r\nint main()\r\n{\r\n   Derived d;\r\n   return 0;\r\n}', 'Compiler Dependent', 'Base1â€²s constructor called\r\nBase2â€²s constructor called\r\nDerivedâ€™s constructor called', 'Base2â€²s constructor called\r\nBase1â€²s constructor called\r\nDerivedâ€™s constructor called', 'Compiler Error', 'B', 'When a class inherits from multiple classes, constructors of base classes are called in the same order as they are specified in inheritance.', 'C', 'D'),
(13, '#include<iostream>\r\n#include<string.h>\r\nusing namespace std;\r\n \r\nclass String\r\n{\r\n    char *str;\r\npublic:\r\n     String(const char *s);\r\n     void change(int index, char c) { str[index] = c; }\r\n     char *get() { return str; }\r\n};\r\n \r\nString::String(const char *s)\r\n{\r\n    int l = strlen(s);\r\n    str = new char[l+1];\r\n    strcpy(str, s);\r\n}\r\n \r\nint main()\r\n{\r\n   String s1("code-e-Salsa");\r\n   String s2 = s1;\r\n   s1.change(0,  C );\r\n   cout << s1.get() << " ";\r\n   cout << s2.get();\r\n}', 'Code-e-Salsa code-e-Salsa', 'code-e-Salsa code-e-Salsa', 'code-e-Salsa Code-e-Salsa', 'Code-e-Salsa Code-e-Salsa', 'D', 'Since there is no copy constructor, the compiler creates a copy constructor. The compiler created copy constructor does shallow copy in line " String s2 = s1;" So str pointers of both s1 and s2 point to the same location. There must be a user defined copy constructor in classes with pointers ot dynamic memory allocation.', 'A', 'B'),
(14, '#include<iostream>\r\nusing namespace std;\r\n  \r\nclass Test\r\n{\r\npublic:\r\n  Test();\r\n};\r\n  \r\nTest::Test()  {\r\n    cout << " Constructor Called. ";\r\n}\r\n  \r\nvoid fun() {\r\n  static Test t1;\r\n}\r\n  \r\nint main() {\r\n    cout << " Before fun() called. ";\r\n    fun();\r\n    fun();\r\n    cout << " After fun() called. ";  \r\n    return 0;\r\n}', 'Before fun() called. Constructor Called. Constructor Called. After fun() called.', 'Before fun() called. Constructor Called. After fun() called.', 'Before fun() called. After fun() called.', 'Compile Error', 'B', 'Note that t is static in fun(), so constructor is called only once.', 'C', 'D'),
(15, 'Predict the output of following C++ program.\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint &fun()\r\n{\r\n    static int x = 10;\r\n    return x;\r\n}\r\nint main()\r\n{\r\n    fun() = 30;\r\n    cout << fun();\r\n    return 0;\r\n}', '30', '10', '0', 'Compiler Error: Function cannot be used as lvalue', 'A', 'When a function returns by reference, it can be used as lvalue. Since x is a static variable, it is shared among function calls.', 'B', 'C'),
(16, 'Output of following C++ program?\r\n#include<iostream>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n  int x = 10;\r\n  int& ref = x;\r\n  ref = 20;\r\n  cout << "x = " << x << endl ;\r\n  x = 30;\r\n  cout << "ref = " << ref << endl;\r\n  return 0;\r\n}', 'x = 20\r\nRef = 30', 'x = 20\r\nRef = 20', 'x = 10\r\nRef = 30', 'x = 10\r\ny = 20', 'A', 'ref is an alias of x, so if we change either of them, we can see the change in other as well.', 'B', 'C'),
(17, '#include<iostream>\r\n  \r\nusing namespace std;\r\nclass P {\r\npublic:\r\n   void print()  { cout <<" Inside P"; }\r\n};\r\n  \r\nclass Q : public P {\r\npublic:\r\n   void print() { cout <<" Inside Q"; }\r\n};\r\n  \r\nclass R: public Q { };\r\n  \r\nint main(void)\r\n{\r\n  R r; \r\n  r.print();\r\n  return 0;\r\n}', 'Inside P', 'Inside Q', 'Inside P\r\nInside Q', 'Compile Error', 'B', 'The print function is not present in class R. So it is looked up in the inheritance hierarchy. print() is present in both classes P and Q, which of them should be called? The idea is, if there is multilevel inheritance, then function is linearly searched up in the inheritance hierarchy until a matching function is found.', 'A', 'D'),
(18, 'Inline functions are useful when', 'Function is large with many nested loops', 'Function has many static variables', 'Function is small and we want to avoid function call overhead', 'None of the above', 'C', 'Inline functions are generally used in place of small macros. They are substitute to macros and better than macros', 'A', 'D'),
(19, '#include<iostream>\nusing namespace std;\nint x = 1;\nvoid fun()\n{\n    int x = 2;\n    {\n        int x = 3;\n        cout << ::x << endl;\n    }\n}\nint main()\n{\n    fun();\n    return 0;\n}', '1', '2', '3', 'Compile Error', 'A', 'The value of ::x is 1. The scope resolution operator when used with a variable name, always refers to global variable.', 'C', 'D'),
(20, 'Which of the following overloaded functions are allowed in C++?', 'int fun(int x, int y);\r\n         void fun(int x, int y);', '2) Functions that differ only by static keyword in return type\r\n    int fun(int x, int y);\r\n         static int fun(int x, int y);', '3)Parameter declarations that differ only in a pointer * versus an array []\r\nint fun(int *ptr, int n);\r\nint fun(int ptr[], int n);', 'None of the above', 'D', ' Function declarations that differ only in the return type', 'A', 'C'),
(21, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n    int main = 10;\r\n    printf("%d",main);\r\n    return 0;\r\n}\r\n\r\nWhat will happen if above piece of code is executed?', 'It will cause a compile-time error', 'It will cause a run-time error', 'It will run without any error and prints 10', 'It will experience infinite loop', 'C', 'main is not a reserved keyword.', 'A', 'D'),
(22, '#include<stdio.h>\r\n\r\nvoid main()\r\n{\r\n    unsigned int x = -5;\r\n    printf("%d",x);\r\n}\r\n\r\nPredict the output.', '-5', 'Run time error', 'Garbage Value', '5', 'A', 'Note the format specifier in printf()', 'B', 'D'),
(23, '#include<stdio.h>\r\n\r\nvoid main()\r\n{\r\n    int x=0, y=2, z=3;\r\n    int a = x & y | z;\r\n    printf("%d",a);\r\n}\r\n\r\nPredict the output.', '3', '0', '2', 'Run time error', 'A', '| and & are bitwise OR AND operations.', 'C', 'D'),
(24, '#include<iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int k=4;\r\n    int* const p = &k;\r\n    int r = 3;\r\n    p = &r;\r\n    cout << p;\r\n}\r\n\r\nComment on output of above code', 'Address of k', 'Address of r', 'Compile time error', 'Address of p', 'C', 'assignment of read-only varible p not allowed', 'B', 'D'),
(25, 'void main()\r\n{\r\n    printf("Welcome to Sinhgad Karandak");\r\n}\r\n\r\nWhat happens when above code is executed?', 'void main()\r\n{\r\n    printf("Welcome to Sinhgad Karandak");\r\n}\r\n\r\nWhat happens when above code is executed?', 'Error due to missing header file', 'No error, but does not print anything', 'None of the above', 'A', '#include does not import the library, it merely copies the function definitions. Linker imports the required functions. Compiler by default imports stdio', 'B', 'C'),
(26, '#include<stdio.h>\r\nvoid main()\r\n{\r\n    int a[] = {5,1,15,20,25};\r\n    int i,j,m;\r\n    i = ++a[1];\r\n    j = a[1]++;\r\n    m = a[i++];\r\n    printf("%d %d %d",i,j,m);\r\n} \r\n\r\nPredict output of above code.', '3 2 20', '2 2 20', '2 2 15', '3 2 15', 'D', 'pre-increament : evaluated at the start of statement evaluation', 'B', 'C'),
(27, '#include<stdio.h>\r\nvoid main()\r\n{\r\n    int a[] = {5,1,15,20,25};\r\n    int i,j,m;\r\n    i = ++a[1];\r\n    j = a[1]++;\r\n    m = a[i++];\r\n    printf("%d %d %d",i,j,m);\r\n} \r\n\r\nPredict output of above code.', '3 2 20', '2 2 20', '2 2 15', '3 2 15', 'D', 'Pre-increament : evaluated at the start', 'A', 'B'),
(28, ' Which of the following is not the member of class?', 'Static function', 'Friend function', 'Const function', 'Virtual function', 'B', 'A non member can have access to the private member of a class', 'C', 'S'),
(29, 'Destructors are called _______', 'in the same order of constructor calls', ' in the reverse order of constructor calls', ' in any random order', 'none of these', 'B', 'They are the function that is called when an object is deleted.', 'C', 'D'),
(30, 'for(;;)', 'Not Valid', 'Skip Looping', 'Loop forever', 'None of the mentioned', 'C', 'No variable is defined in the for loop. No condition is given to stop the loop. It is used similar to what we do to keep our program running always.', 'A', 'D'),
(31, 'Objects of different classes can be added', 'No', 'Sometimes', 'Yes', 'Can''t Say', 'C', 'Surprise. You ', 'A', 'D'),
(32, '"#include<iostream>\r\n\r\nusing namespace std;\r\nclass abc\r\n{\r\npublic:\r\n    int i;\r\n    abc(int i)\r\n    {\r\n         i = i;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n   abc m(5);\r\n   cout<<m.i;\r\n   return 0;\r\n}\r\n\r\nWhat will be the output of above code?\r\n\r\n', '5', 'Garbage Value', 'Error at statement i=i', '', 'B', 'Here i=i in the constructor intialises to itself. ', 'A', 'D'),
(33, 'A virtual function is a member function that expects to be _________ in a derived class. ', 'overridden', 'private', 'ignored', 'called frequently', 'A', 'To redefine in derived classes', 'D', 'B'),
(34, 'Select the incorrect statent from the following', 'the overload operators follow the syntax rules of original operator ', 'only existing operator can be overload', 'operator must have at least one operand of its class type', 'overload operator can change the meaning of the original operator ', 'D', 'Oops! Sorry no hint available', 'A', 'B'),
(35, 'A _____________ pointer can point to ____________ object. ', 'derived class, base class', 'void, derived class', 'void, NULL', 'base class, derived class', 'D', 'The Derived class object contains the Base class object. This allows it to call its Base functions. Whereas a Base class object does not contain a Derived class object', 'B', 'C'),
(36, 'what happen on execution of the following code\r\nclass base { \r\n//code\r\n};\r\nclass derived:protected base {\r\n//code\r\n};', 'it will not compile as the class body of base class is not defined ', 'it will not compile as the class body of derived class is not defined ', 'it will compile successfully', 'the compilation is depend upon the type of data provided to it.', 'C', 'Compilation does not depends on contents of the class', 'A', 'D'),
(37, 'When you derive a class privately, a protected base class member becomes', 'private', 'public ', 'not inherited ', 'protected', 'A', ' The derived class can access the public and protected members in both cases', 'B', 'C'),
(38, 'What does the derived class does not  inherit from the base class ?', 'constructor and destructor', 'operator=() members', 'friend', 'all of these', 'D', 'The derived class inherit everything from the base class except the given things.', 'B', 'C'),
(39, 'Which of the following statements is correct about the constructors and destructors?', 'Destructors can take arguments but constructors cannot.', 'Constructors can take arguments but destructors cannot.', 'Destructors can be overloaded but constructors cannot be overloaded.', 'Constructors and destructors can both return a value.', 'B', 'Destructor basically destroys everythings but constructor has to initialize the variables in many cases.', 'A', 'D'),
(40, 'Select the correct option\r\nI. A pure virtual is always implemented in the class in which it is declared \r\nII. An abstract class cannot contain pure virtual function', 'only I is true', 'only II is true', 'both I and II is true', 'neither I nor II is true', 'D', 'Abstract class can have normal functions and variables along with a pure virtual function and must be defined outside the class definition.', 'A', 'C'),
(41, '  \r\n\r\nHow can we make a class abstract?', 'By making all member functions constant.', 'By making at least one member function as pure virtual function.', 'By declaring it abstract using the static keyword.', 'By declaring it abstract using the virtual keyword.', 'B', 'Abstract classes cannot be instantiated, but they can be subclassed. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class.', 'D', 'A'),
(42, 'Identify user defined types from following', 'Enumeration', 'Classes', 'Both A and B', 'String', 'C', 'A user-defined type facilitates handling multiple fields of related information in a table.', 'A', 'D'),
(43, 'For what values of expression in if-statement, the block is not executed?', '0 and all negative', '0 and -1', '', '0, all negative and positive values except 1', 'C', 'A block is a sequence of statements, local class declarations and local variable declaration statements within braces.', 'A', 'D'),
(44, '        #include <iostream>\r\n        using namespace std;\r\n        class Base1\r\n        {\r\n            protected:\r\n            int SampleDataOne;\r\n            public:\r\n            Base1()\r\n            {\r\n                SampleDataOne = 100;\r\n            }\r\n            ~Base1()\r\n            {\r\n            }\r\n            int SampleFunctOne()\r\n            {\r\n                return SampleDataOne;\r\n            }\r\n        };\r\n        class Base2\r\n       {\r\n            protected:\r\n            int SampleDataTwo;\r\n            public:\r\n            Base2()\r\n            {\r\n                SampleDataTwo = 200;\r\n            }\r\n            ~Base2()\r\n            {\r\n            }\r\n            int SampleFunctTwo()\r\n            {\r\n                return SampleDataTwo;\r\n            }\r\n        };\r\n        class Derived1 : public Base1, public Base2\r\n        {\r\n            int MyData;\r\n            public:\r\n            Derived1() \r\n            {\r\n                MyData = 300;\r\n            }\r\n            ~Derived1()\r\n            {\r\n            }    \r\n            int MyFunct()\r\n            {\r\n                return (MyData + SampleDataOne + SampleDataTwo);\r\n            }\r\n        };\r\n        int main()\r\n        {\r\n            Base1 SampleObjOne;\r\n            Base2 SampleObjTwo;\r\n            Derived1 SampleObjThree;\r\n            cout << SampleObjThree.Base1 :: SampleFunctOne() << endl;\r\n            cout << SampleObjThree.Base2 :: SampleFunctTwo() << endl;\r\n            return 0;\r\n        }', '100', '200', 'both a and b', 'none of these', 'C', 'Values of defined class object in main function will be executed', 'B', 'D'),
(45, 'cout is a/an', 'operator', 'function', 'object', 'macro ', 'C', 'It corresponds to the cstdio stream stdout.', 'D', 'A'),
(46, 'To where does the program control transfers when exception is raised?', 'Catch', 'handlers', 'throw', 'none', 'B', 'Exceptions provide a way to transfer control from one part of a program to another.', 'C', 'D'),
(47, ' int *ptr[10]; is', 'an array of 10 int pointers', ' a pointer of 10 int elements', 'an array of 10 elements returning an int value', 'none of these', 'A', 'Its array of type integer. Elemens are all pointers', 'B', 'C'),
(48, 'What is the output of this program?\r\n#include <iostream>\r\nusing namespace std;\r\nvoid PrintSequence(int StopNum)\r\n {\r\n        int Num;\r\n        Num = 1;\r\n        while (true) {\r\n            if (Num >= StopNum)\r\n                throw Num;\r\n            cout << Num;\r\n            Num++;\r\n        }\r\n     }\r\n     int main(void)\r\n     {\r\n        try {\r\n            PrintSequence(20);\r\n        }\r\n        catch(int ExNum)\r\n        {\r\n            cout << "Caught an exception with value: " << ExNum;\r\n        }\r\n        return 0;\r\n     }', 'Compile time error', 'Prints first 19 numbers', 'Prints first 19 numbers and throws exception at 20', 'None of these', 'C', 'Program executes in a usual way.', 'D', 'A'),
(49, 'To declare a pointer to a member of a class which operator is used', '*', '::*', '*::', '.*', 'B', ':: is used to access member of a class.It can be any varable, function or pointer.', 'C', 'D'),
(50, '#include <iostream>\n        using namespace std;\n        class polygon \n        {\n            protected:\n            int width, height;\n            public:\n            void set_values (int a, int b)\n            { \n                width = a; height = b;}\n            }               };\n            class output1 \n            {\n                public:\n                    void output (int i);\n            }\n        void output1::output (int i) \n        {\n            cout << i << endl;\n        }\n       class rectangle: public polygon, public output1 \n       {\n           public:\n           int area ()\n            { \n                return (width * height); \n            }\n        };\n        class triangle: public polygon, public output1 \n        {\n            public:\n            int area ()\n            {\n                return (width * height / 2); \n            }\n        };\n        int main () \n        {\n            rectangle rect;\n            triangle trgl;\n            rect.set_values (4, 5);\n            trgl.set_values (4, 5);\n            rect.output (rect.area());\n            trgl.output (trgl.area());\n            return 0;\n        }\n', '10 20', '20 20', '20 10', 'Error', 'C', 'Function which is called first will generate the output prior to other functions.', 'A', 'B'),
(51, 'Choose most appropriate statement \r\n', 'An abstract base class can have pure virtual destructor', 'An abstract base class can have only virtual destructor', 'An abstract base class can have non virtual destructor', 'An abstract base class cannot have destructor', 'D', ' The destructor is the only method that even if it is pure virtual has to have an implementation in order to instantiate derived classes.', 'A', 'C');

-- --------------------------------------------------------

--
-- Table structure for table `hard`
--

CREATE TABLE `hard` (
  `id` tinyint(11) NOT NULL,
  `question` text NOT NULL,
  `option1` text NOT NULL,
  `option2` text NOT NULL,
  `option3` text NOT NULL,
  `option4` text NOT NULL,
  `answer` char(1) NOT NULL,
  `hint` varchar(500) NOT NULL,
  `wrong1` char(1) NOT NULL,
  `wrong2` char(1) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `hard`
--

INSERT INTO `hard` (`id`, `question`, `option1`, `option2`, `option3`, `option4`, `answer`, `hint`, `wrong1`, `wrong2`) VALUES
(1, '#include<stdio.h>\n#define f(g,g2) g##g2\nint main()\n{\n   int var12 = 100;\n   printf("%d", f(var,12));\n   getchar();\n   return 0;\n}', 'Compilation error', 'var##12', '100', 'None of the above', 'C', 'hint', 'D', 'B'),
(2, '// Assume that integers take 4 bytes.\n#include<iostream>\n \nusing namespace std;   \n \nclass Test\n{\n  static int i;\n  int j;\n};\n \nint Test::i;\n \nint main()\n{\n    cout << sizeof(Test);\n    return 0;\n}', '8', '4', '6', 'None of the above', 'B', 'hint', 'A', 'C'),
(3, '#include <iostream>\nusing namespace std;\n \ntemplate <typename T>\nvoid fun(const T&x)\n{\n    static int count = 0;\n    cout << "x = " << x << " count = " << count << endl;\n    ++count;\n    return;\n}\n \nint main()\n{\n    fun<int> (1); \n    cout << endl;\n    fun<int>(1); \n    cout << endl;\n    fun<double>(1.1);\n    cout << endl;\n    return 0;\n}', 'x = 1 count = 0\r\n\r\nx = 1 count = 1\r\n\r\nx = 1.1 count = 0', 'x = 1 count = 0\r\n\r\nx = 1 count = 0\r\n\r\nx = 1.1 count = 0', 'x = 1 count = 0\r\n\r\nx = 1 count = 1\r\n\r\nx = 1.1 count = 2', 'Compilation error', 'A', 'hint', 'B', 'D'),
(4, '#include <iostream>\nusing namespace std;\n  \ntemplate<int n> struct funStruct\n{\n    static const int val = 2*funStruct<n-1>::val;\n};\n  \ntemplate<> struct funStruct<0>\n{\n    static const int val = 1 ;\n};\n  \nint main()\n{\n    cout << funStruct<10>::val << endl;\n    return 0;\n}', '1024', '1', '2', 'Compilation Error', 'A', 'This is an example ofÂ template metaprogramming The program mainly calculates 2^10.', 'C', 'D'),
(5, '#include<iostream>\nusing namespace std;\nclass Base\n{\npublic:\n    virtual void show() = 0;\n};\n \nclass Derived : public Base { \nvoid print(){\n        cout<<â€In Derivedâ€;\n} \n};\n \nint main(void)\n{\n    Derived q;\n    q.print();\n    return 0;\n}', 'In Derived', '0', 'No output', 'Compilation Error', 'D', 'If we dont override the pure virtual function in derived class, then derived class also becomes abstract class.', 'B', 'C'),
(6, '#include <iostream>\nusing namespace std;\n \nclass Test \n{\n  int x;\n  Test() { x = 5;}\n};\n \nint main()\n{\n   Test *t = new Test;\n   cout << t->x;\n}', 'Garbage Value\r\n', '5', '0', 'Compile error', 'D', 'There is compiler error: Test::Test() is private. new makes call to the constructor. In class Test, constructor is private (note that default access is private in C++).', 'B', 'A'),
(7, '#include <iostream>\nusing namespace std;\nint main()\n{\n    const char* p = "12345";\n    const char **q = &p;\n    *q = "abcde";\n    const char *s = ++p;\n    p = "XYZWVU";\n    cout << *++s;\n    return 0;\n}', 'Compiler Error', 'c\r\n', 'b\r\n', 'Garbage Value\r\n', 'B', 'const char* p = â€œ12345â€³ declares a pointer to a constant. So we canâ€™t assign something else to *p, but we can assign new value to p. const char **q = &p; declares a pointer to a pointer. We canâ€™t assign something else to **q, but we can assign new values to q and *q. *q = â€œabcdeâ€; changes p to point to â€œabcdeâ€ const char *s = ++p; assigns address of literal â€bcdeâ€ to s. Again *s canâ€™t be assigned a new value, but s can be changed. The statement printf(â€œ%cnâ€, *++s) chang', 'A', 'D'),
(8, '"#include <iostream>\nusing namespace std;\nclass Point\n{\n    int x, y;\npublic:\n Point(int i = 0, int j =0)\n   { x = i; y = j;  }\n   int getX() const { return x; }\n   int getY() {return y;}\n};\n \nint main()\n{\n    const Point t;\n    cout << t.getX() << "" "";\n    cout << t.getY();\n    return 0;\n}"\n', 'Garbage Values\r\n', '0 0\r\n', '"Compiler Error in line\r\n Cout << t.getX() << "" "";"\r\n', '"Compiler Error in line\r\n Cout << t.gety();"\r\n', 'D', 'A const object can only call const functions.', 'A', 'B'),
(9, '"#include <iostream>\n#include<string>\nusing namespace std;\n \nclass Base\n{\npublic:\n    virtual string print() const\n    {\n        return ""This is Base class"";\n    }\n};\n \nclass Derived : public Base\n{\npublic:\n    virtual string print() const\n    {\n        return ""This is Derived class"";\n    }\n};\n \nvoid describe(Base p)\n{\n    cout << p.print() << endl;\n}\n \nint main()\n{\n    Base b;\n    Derived d;\n    describe(b);\n    describe(d);\n    return 0;\n}"\n', '"This is Derived class\r\nThis is Base class"\r\n', '"This is Base class\r\nThis is Derived class"\r\n', '"This is Base class\r\nThis is Base class"\r\n', 'Compile Error\r\n', 'C', 'Note that an object of Derived is passed in describe(d), but print of Base is called. The describe function accepts a parameter of Base type. This is a typical example of object slicing, when we assign an object of derived class to an object of base type, the derived class object is sliced off and all the data members inherited from base class are copied. Object slicing should be ovoided as there may be surprising results like above. As a side note, object slicing is not possible in Java. In Jav', 'A', 'D'),
(10, '"What is the return value of f(p, p) if the value of p is initialized to 5 before the call? Note that the first parameter is passed by reference, whereas the second parameter is passed by value.\nint f(int &x, int c) {\n   c  = c - 1;\n   if (c == 0) return 1;\n   x = x + 1;\n   return f(x, c) * x;\n}"\n', '3024\r\n', '6561\r\n', '55440\r\n', '161051\r\n', 'B', 'Since c is passed by value and x is passed by reference, all functions will have same copy of x, but different copies of c. f(5, 5) = f(x, 4)*x = f(x, 3)*x*x = f(x, 2)*x*x*x = f(x, 1)*x*x*x*x = 1*x*x*x*x = x^4 Since x is incremented in every function call, it becomes 9 after f(x, 2) call. So the value of expression x^4 becomes 9^4.', 'C', 'A'),
(11, '"Predict the output?\n#include<stdlib.h>\n#include<stdio.h>\n#include<iostream>\n \nusing namespace std;\n \nclass Test {\n    int x;\npublic:\n    void* operator new(size_t size);\n    void operator delete(void*);\n    Test(int i) {\n        x = i;\n        cout << ""Constructor called \n"";\n    }\n    ~Test() { cout << ""Destructor called \n""; }\n};\n \n \nvoid* Test::operator new(size_t size)\n{\n    void *storage = malloc(size);\n    cout << ""new called \n"";\n    return storage;\n}\n \nvoid Test::operator delete(void *p )\n{\n    cout<<""delete called \n"";\n    free(p);\n}\n \nint main()\n{\n    Test *m = new Test(5);\n    delete m;\n    return 0;\n}"\n', '"new called\r\nConstructor called\r\ndelete called\r\nDestructor called"\r\n', '"new called\r\nConstructor called\r\nDestructor called\r\ndelete called"\r\n', '"Constructor called\r\nnew called\r\nDestructor called\r\ndelete called"\r\n', '"Constructor called\r\nnew called\r\ndelete called\r\nDestructor called"\r\n', 'B', '"Consider the following statement     Test *ptr = new Test;   There are actually two things that happen in the above statement--memory allocation and object construction; the new keyword is responsible for both. One step in the process is to call operator new in order to allocate memory; the other step is to actually invoke the constructor. Operator new only allows us to change the memory allocation method, but does not do anything with the constructor calling method. Keyword new is responsible ', 'A', 'D'),
(12, '"#include <iostream>\nusing namespace std;\nclass Test2\n{\n    int y;\n};\n \nclass Test\n{\n    int x;\n    Test2 t2;\npublic:\n    operator Test2 ()  { return t2; }\n    operator int () { return x; }\n};\n \nvoid fun ( int x) { cout << ""fun(int) called""; }\nvoid fun ( Test2 t ) { cout << ""fun(Test 2) called""; }\n \nint main()\n{\n    Test t;\n    fun(t);\n    return 0;\n}"\n', 'fun(int) called\r\n', 'fun(Test 2) called\r\n', '"fun(int) called \r\nfun(Test2)called"\r\n', 'Compile Error\r\n', 'D', 'The class Test has two conversion operators overloaded, int and Test2. And there are two fun() for int and Test2.', 'A', 'C'),
(13, '"#include<stdio.h>\nstruct emp\n{\n    int id;\n    char name[10];\n    float f;\n}e1;\nmain()\n{\n    printf(""%d"",sizeof(e1));\n}\n\nPredict the output of above code, consider size of int=2 bytes"\n', '10\r\n', '16\r\n', '18\r\n', '20\r\n', 'D', 'Answer is 20 instead of 16 because of padding ', 'A', 'C'),
(14, '"#include <stdio.h>\n#define ISEQUAL(X, Y) X == Y\nint main()\n{\n    #if ISEQUAL(X, 0)\n        printf(""Geeks"");\n    #else\n        printf(""Quiz"");\n    #endif\n    return 0;\n}\n\nPredict the output."\n', 'Geeks\r\n', 'Quiz\r\n', 'Compilation Error\r\n', 'Garbage Value\r\n', 'A', 'The conditional macro #if ISEQUAL(X, 0) is expanded to #if X == 0. After the pre-processing is over, all the undefined macros are initialized with default value 0. Since macro X has not been defined, it is initialized with 0. So, "Geeks" is printed.', 'C', 'D'),
(15, '"#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int a=10, b=20, c=30, d=40, e=50;\n    cout << (a, b, c, d, e);\n    return 0;\n}\n\nPredict the output of above code.\n', '10\r\n', '50\r\n', 'Syntax Error\r\n', '150\r\n', 'A', '"Comma opreator evaluates to last value. So only e will be considered."', 'C', 'D'),
(16, '"#include <stdio.h>\n#define f(a,b) yes\n#define g(a)   #a\n#define h(a) g(a)\n\n  int main()\n  {\n        printf(""%s\n"",h(f(1,2)));\n        printf(""%s\n"",g(f(1,2)));\n        return 0;\n  }\nPredict the output"\n', '"yes\r\nyes"\r\n\r\n', '"f(1,2)\r\nf(1,2)"\r\n\r\n', '"yes\r\nf(1,2)"\r\n', 'Syntax Error\r\n', 'B', 'These are nested macros, which expand themselves with given parameters, thus giving B as output', 'A', 'C'),
(17, '"#include<stdio.h>\nint main()\n{\n    int i;\n    for (i = 0; i<5; i++)\n    {\n        int i;\n        i = 10;\n        printf(""%d "", i) ;\n    }\n    return 0;\n}\n\nWhat will be the output of above code?"\n', '10\r\n', 'Infinite loop\r\n', '0 1 2 3 4\r\n', '10 10 10 10 10\r\n', 'D', 'The loop will iterate 5 times, thus printing 10 five times', 'A', 'C'),
(18, '"#include<iostream>\nusing namespace std;\n\nvoid display(int data[])\n{\n        cout<<""\nSize of array when passed as argument is : ""<<sizeof(data);\n}\n\nint main()\n{\n    int data[] = { 1, 2, 3, 4, 5, 6};\n    cout<<""\nSize of array is : ""<<sizeof(data);\n    display(data);\n    return 0;\n}\n\nCONSIDER SIZE OF INT = 4 bytes\nWhat will be the output produced?\n', '"Size of array is : 24 \r\nSize of array when passed as argument is : 4"\r\n', '"Size of array is : 24 \r\nSize of array when passed as argument is : 24"\r\n', '"Size of array is : 4 \r\nSize of array when passed as argument is : 4"\r\n', '"Size of array is : 4\r\nSize of array when passed as argument is : 24"\r\n', 'A', 'Since array has 6 elements, its size is 6*4', 'B', 'D'),
(19, '"#include <stdio.h>\n  int main()\n  {\n    int a=3, b=5;\n\n    printf(&a[""Ya!Hello! how is this? %s\n""], &b[""cool/super""]);\n    printf(&a[""WHAT%c%c%c  %c%c  %c !\n""], 1[""this""],\n       2[""beauty""],0[""tool""],0[""is""],3[""sensitive""],4[""CCCCCC""]);\n    return 0;\n  }\n\nPredict the output.', '"Ya!Hello! how is this?\r\ncool/super\r\nWHAT\r\nthis\r\nbeauty tool is sensitive CCCCCC\r\n"', '"Hello! how is this? cool\r\nThat  is C \r\n"', '"Hello! How is this? super\r\nC   is beauty"\r\n', '"Ya!Hello! how is this? cool/super\r\nC  is sensitive\r\n"\r\n', 'B', 'Since we are passing characters to Interegs a & b, some characters get ommitted during printing', 'A', 'D'),
(20, '. What is the output?\n#include <stdio.h>\n\n#define decode(s,t,u,m,p,e,d) m ## s ## u ## t\n#define begin decode(a,n,i,m,a,t,e)\n\nbegin()\n{\n    printf("Stumped?\n");\n}\n', 'Stumped?', 'animate', 'Compilation error', 'Run time error', 'A', 'When the preprocessor works on this code, begin() is replaced with decode(a,n,i,m,a,t,e)(), decode(a,n,i,m,a,t,e)() is replaced with m ## a ## i ## n(), m ## a ## i ## n() is replaced with main()  Thus effectively, begin() is replaced with main().', 'B', 'D'),
(21, 'What will be the output?\n#include<iostream>\n#include<stdio.h>\n#include<unistd.h>\nusing namespace std;\nvoid main()\n{\n	if (fork()||fork()||fork())\n		cout<<"Hello";\n	cout<<"Hello";	\n}\n', 'HelloHelloHello', 'HelloHelloHelloHelloHelloHelloHello', 'Hello', 'HelloHelloHelloHelloHelloHello', 'B', 'After exectution of fork() call, both parent and child execute the remaining code.', 'A', 'C'),
(22, 'What is output of following code?\n#include<iostream.h>\n#include<string.h>\nvoid main()\n{\n    char *s;\n    s="hot java";\n    strcpy(s,"solaris java");\n    printf("%s", s);\n}', 'hot java', 'solaris java', 'compilation error', 'Segmentation fault', 'D', 'char *s initialization will place "hot java" in the read-only parts of the memory, and making s a pointer to that makes any writing operation on this memory illegal. Thus during execution of strcpy() segmenation fault occurs.', 'C', 'B'),
(23, 'void f(int i)\n{\n    int j;\n    for (j=0;j<16;j++)\n    {\n        if (i & (0x8000>>j))\n            printf("1");\n        else\n            printf("0");\n    }\n}\nWhat is the purpose of the function ?', 'a)prints hex representation of i', 'prints decimal representation of i ', ' prints binary representation of i ', 'none', 'C', 'Using & 0x8000 is a fast way to see if a certain bit is set. The & operator is a bitwise and. So using this will return 0 in all cases except for when the high bit is set.', 'B', 'A'),
(24, 'In below code snippet, How many time solaris will be printed?\n#include\nmain()\n{\n     int ret;\n     ret=fork();ret=fork();ret=fork();ret=fork();\n     if(!ret)\n         printf("sun");\n     else\n         printf("solaris");\n}', '16', '1', '8', '4', 'C', 'After first fork(), both parent and child process will execute next fork() and so on. Thus 16 processes are created, from which 8 will print "sun" and remaining 8 will print "solaris".', 'B', 'D'),
(25, '#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nstruct g\n{\n	g():n(0){}\n	int operator()() { return n++; }\n	int n;\n};\n\nint main()\n{\n	int a[10];\n	std::generate(a, a+10, g());\n	std::copy(a, a+10, std::ostream_iterator<int>(std::cout, " "));\n}\nWhat will be the output?\n', '0', '0 1 2 3 4 5 6 7 8', '1 2 3 4 5 6 7 8 9', '0 1 2 3 4 5 6 7 8 9', 'D', 'The function main() uses the generate algorithm to initialise the int array using functor g. This functor will be called for every element within the array, with the result of the call use to initialise that element. Once initialise, the whole array is copied to the standard output stream using the copy algorithm. Most of STL makes good use of functors and there are some neat reusable generic algorithms, which can be used to make code simple and easier to maintain.', 'A', 'B'),
(26, 'output of following code will be ? \n#include<iostream.h>\nusing namespace std;\nint main(){}\n', '\r\nCompilation error', 'Runtime error', 'Successful compilation', 'Exception : return type not found', 'C', 'main() is the only function that compiles successfully even though no value is explicitly returned. Compiler implicitly returns the function, if not explicitly done.', 'A', 'B'),
(27, 'what is the value of st where noted by the comment?\nstruct Foo\n{\n   virtual size_t func(size_t st = 0) const = 0;\n};\n\nstruct Bar : Foo\n{\n   virtual size_t func(size_t st = 999) const\n   {\n      return st;\n   }\n};\n\nint main()\n{\n   Foo const & foo = Bar();\n   size_t st = foo.func(); // What value does st have?\n}\n', '0', '999', '0999', 'None of above', 'A', ' On return st will be assigned 0 and not, as one would intuitively expect, 999. The reason for this is because default parameters are always bound to the static and NOT dynamic type. This case be a very hard to track down source of defects, be very careful when using default parameters with virtual functions.', 'B', 'C'),
(28, 'What does the following function do?\n    float F1 (float x){\n    float xhalf = 0.5f*x;\n    int i = *(int*)&x;\n    i = 0x5f3759df - (i>>1);\n    x = *(float*)&i;\n    x = x*(1.5f - xhalf*x*x);\n    return x;\n}\n', 'Returns square of input number', 'Returns square root of input number', 'Returns inverse square root of input number', 'Undefined output', 'C', 'This program calculates inverse square root of a number, minimizing computation time.', 'A', 'B'),
(29, 'What is output of this program?\n#include <iostream>\n    using namespace std;\n    int main ()\n    {\n        cout << "Value of __LINE__ : " << __LINE__ << endl;\n        cout << "Value of __FILE__ : " << __FILE__ << endl;\n        cout << "Value of __DATE__ : " << __DATE__ << endl;\n        cout << "Value of __TIME__ : " << __TIME__ << endl;\n        return 0;\n    }\n\n', 'Run time error', 'Details about your file', 'compile time error', 'none of the mentioned', 'B', 'In this program, we are using the macros to print the information about the file.', 'A', 'D'),
(30, 'What is output of this program?\n    #include <iostream>\n    using namespace std;\n    #define PR(id) cout << "The value of " #id " is "<<id\n    int main()\n    {\n        int i = 10;\n        PR(i);\n        return 0;\n    }\n', '10', 'No output', '20', 'Syntax error', 'A', 'PR(i) function call transfers control to #define structure', 'B', 'C'),
(31, 'What is output of this program? \r\n#include <iostream>\r\n    using namespace std;\r\n    #define SquareOf(x) x * x\r\n    int main()\r\n    {\r\n        int x;\r\n        cout << SquareOf(x + 4);\r\n        return 0;\r\n    }', '16', '64', 'compile time error', 'none of the mentioned', 'D', 'In this program, as we havenâ€™t initiailzed the variable x, we will get a output of ending digit of 4.', 'A', 'B'),
(32, 'What will be the output of the program?\r\n#include <iostream>\r\n    using namespace std;\r\n    enum test {\r\n        A = 32, B, C\r\n    };\r\n    int main()\r\n    {\r\n        cout << A << B<< C;\r\n        return 0;\r\n    }\r\n', '323334', '323232', '323130', 'none of the mentioned', 'A', 'If we not assigned any value to enum variable means, then the next number to initialized number will be allocated to the variable.', 'D', 'C'),
(33, 'What is the output of this program?\r\n    #include <iostream>\r\n    using namespace std;\r\n    enum colour {\r\n        green, red, blue, white, yellow, pink\r\n    };\r\n    int main()\r\n    {\r\n        cout << green<< red<< blue<< white<< yellow<< pink;\r\n        return 0;\r\n    }\r\n', '012345', '123456', 'compile time error', 'runtime error', 'A', 'The enumerator values start from zero if it is unassigned.', 'B', 'D'),
(34, '"#include<stdio.h>\r\nvoid mystery(int *ptra, int *ptrb)\r\n{\r\nint *temp;\r\ntemp = ptrb;\r\nptrb = ptra;\r\nptra = temp;\r\n}\r\nint main()\r\n{\r\nint a=2016, b=0, c=4, d=42;\r\nmystery(&a, &b);\r\nif (a < c)\r\nmystery(&c, &a);\r\nmystery(&a, &d);\r\nprintf(""%d\n"", a);\r\n}\r\nOutput of above code is?"\r\n', '2016\r\n', '0\r\n', '4\r\n', '42\r\n', 'A', 'mystery() is a swap function, that is called multiple times.', 'D', 'B'),
(35, '"#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\nif(~5 == -6)\r\ncout << ""Yes"";\r\nelse\r\ncout << ""No"";\r\n}\r\n\r\nPredict the output."\r\n', 'Yes\r\n', 'No\r\n', 'Compile time error\r\n', 'Run time error\r\n', 'A', '~ operator is a bitwise operator that finds ones complement of the number.', 'B', 'D'),
(36, '"#include <stdio.h>\r\nint main()\r\n{\r\nchar dummy[80];\r\nprintf(""Enter a string:\n"");\r\nscanf(""%[^a]"",dummy);\r\nprintf(""%s\n"",dummy);\r\nreturn 0;\r\n}\r\n\r\nWhat will be the output of above code if input is LIFE IS BEAUTIFUL?"\r\n', 'LIFE IS BEAUTIFUL\r\n', 'LIFE\r\n', 'LIFE IS BE\r\n', 'Compile time error\r\n', 'C', '^ is xor operator. Thus as soon as scanf function encounters "a", it is terminated.', 'A', 'D');

-- --------------------------------------------------------

--
-- Table structure for table `intermediate`
--

CREATE TABLE `intermediate` (
  `id` tinyint(11) NOT NULL,
  `question` text NOT NULL,
  `option1` text NOT NULL,
  `option2` text NOT NULL,
  `option3` text NOT NULL,
  `option4` text NOT NULL,
  `answer` char(1) NOT NULL,
  `hint` varchar(500) NOT NULL,
  `wrong1` char(1) NOT NULL,
  `wrong2` char(1) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `intermediate`
--

INSERT INTO `intermediate` (`id`, `question`, `option1`, `option2`, `option3`, `option4`, `answer`, `hint`, `wrong1`, `wrong2`) VALUES
(1, '#include<iostream>\r\nusing namespace std;\r\n \r\nclass Base {};\r\nclass Derived: public Base {};\r\nint main()\r\n{\r\n   Derived d;\r\n   try {\r\n       throw d;\r\n   }\r\n   catch(Base b) {\r\n        cout<<"Caught Base Exception";\r\n   }\r\n   catch(Derived d) {\r\n        cout<<"Caught Derived Exception";\r\n   }\r\n   return 0;\r\n}', 'Caught Derived Exception', 'Caught Derived Exception\r\nCaught Base Exception', 'Caught Base Exception', 'Compile Error', 'C', 'If both base and derived classes are caught as exceptions then catch block of derived class must appear before the base class. If we put base class first then the derived class catch block will never be reached. In Java, catching a base class exception before derived is not allowed by the compiler itself. In C++, compiler might give warning about it, but compiles the code.', 'A', 'D'),
(2, 'Output of following program?\r\n#include <iostream>\r\nusing namespace std;\r\n \r\ntemplate <class T>\r\nclass Test\r\n{\r\nprivate:\r\n    T val;\r\npublic:\r\n    static int count;\r\n    Test()  {   count++;   }\r\n};\r\n \r\ntemplate<class T>\r\nint Test<T>::count = 0;\r\n \r\nint main()\r\n{\r\n    Test<int> a;\r\n    Test<int> b;\r\n    Test<double> c;\r\n    cout << Test<int>::count   << endl;\r\n    cout << Test<double>::count << endl;\r\n    return 0;\r\n}', '0\r\n0', '1\r\n1', '2\r\n1', '1\r\n0', 'C', 'There are two classes created by the template: TestÂ and Test. Since count is a static member, every class has its own copy of it. Also, count gets incremented in constructor.', 'A', 'D'),
(3, '#include <iostream>\r\nusing namespace std;\r\n \r\ntemplate <class T, int max>\r\nint arrMin(T arr[], int n)\r\n{\r\n   int m = max;\r\n   for (int i = 0; i < n; i++){\r\n      if (arr[i] < m)\r\n         m = arr[i];\r\n      }\r\n   return m;\r\n}\r\n \r\nint main()\r\n{\r\n   int arr1[]  = {10, 20, 15, 12};\r\n   int n1 = sizeof(arr1)/sizeof(arr1[0]);\r\n \r\n   char arr2[] = {1, 2, 3};\r\n   int n2 = sizeof(arr2)/sizeof(arr2[0]);\r\n \r\n   cout << arrMin<int, 10000>(arr1, n1) << endl;\r\n   cout << arrMin<char, 256>(arr2, n2);\r\n   return 0;\r\n}', 'Compiler error, template argument must be a data type', '10\r\n1', '10000\r\n256', '1\r\n1', 'B', 'We can pass non-type arguments to templates. Non-type parameters are mainly used for specifying max or min values or any other constant value for a particular instance of template. The important thing to note about non-type parameters is, they must be const. Compiler must know the value of non-type parameters at compile time. Because compiler needs to create functions/classes for a specified non-type value at compile time.', 'C', 'D'),
(4, '#include <iostream>\r\nusing namespace std;\r\n \r\ntemplate <class T>\r\nT max (T &a, T &b)\r\n{\r\n    return (a > b)? a : b;\r\n}\r\n \r\ntemplate <>\r\nint max <int> (int &a, int &b)\r\n{\r\n    cout << "Called ";\r\n    return (a > b)? a : b;\r\n}\r\n \r\nint main ()\r\n{\r\n    int a = 10, b = 20;\r\n    cout << max <int> (a, b);\r\n}', '20 Called', 'Called 20', 'Called', 'Compile Error', 'B', 'Above program is an example of template specialization. Sometime we want a different behaviour of a function/class template for a particular data type. For this, we can create a specialized version for that particular data type.', 'A', 'D'),
(5, '#include<iostream>\nusing namespace std;\n \nclass Base\n{\npublic:\n    virtual void show() = 0;\n};\nclass Derived: public Base \n{\npublic: \nvoid show(){\ncout<<â€In Derivedâ€<<endl;\n}\n}\nint main()\n{\n    Base b;\n    Base *bp;\n    Derived d;\nbp=&d;\nbpâ†’show();\n    return 0;\n}', 'Compile Error', 'In Derived', '', 'No Output', 'A', 'Since Base has a pure virtual function, it becomes an abstract class and an instance of it cannot be created. ', 'B', 'C'),
(6, 'How to create a dynamic array of pointers (to integers) of size 10 using new in C++?', 'int *arr = new int *[10];', 'int **arr = new int *[10];', 'int **arr = new int [10];', 'Not Possible', 'B', 'A dynamic array of pointers requires a pointer to a pointer ', 'A', 'D'),
(7, '#include <iostream>\nusing namespace std;\nclass Point\n{\n    int x, y;\npublic:\n Point(int i = 0, int j =0)\n   { x = i; y = j;  }\n   int getX() const { return x; }\n   int getY() {return y;}\n};\n \nint main()\n{\n    const Point t;\n    cout << t.getX() << " ";\n    cout << t.getY();\n    return 0;\n}', 'Garbage Values', '0 0', 'Compiler Error in line\r\n Cout << t.getX() << " ";', 'Compiler Error in line\r\n Cout << t.gety();', 'D', 'A const object can only call const functions.', 'A', 'B'),
(8, '#include<iostream>\nusing namespace std;\n \nclass base {\n    int arr[10];\n};\n \nclass b1: public base { };\n \nclass b2: public base { };\n \nclass derived: public b1, public b2 {};\n \nint main(void)\n{\n  cout << sizeof(derived);\n  return 0;\n}', '40', '80', '', '4', 'B', 'Since b1 and b2 both inherit from class base, two copies of class base are there in class derived. This kind of inheritance without virtual causes wastage of space and ambiguities. virtual base classes are used to save space and avoid ambiguities in such cases.', 'C', 'D'),
(9, '#include<iostream>\nusing namespace std;\n \nclass Point {\npublic:\n    Point() { cout << "Normal Constructor called\n"; }\n    Point(const Point &t) { cout << "Copy constructor called\n"; }\n};\n \nint main()\n{\n   Point *t1, *t2;\n   t1 = new Point();\n   t2 = new Point(*t1);\n   Point t3 = *t1;\n   Point t4;\n   t4 = t3;\n   return 0;\n}', 'Normal Constructor called\r\nNormal Constructor called\r\n\r\nNormal Constructor called\r\n\r\nCopy Constructor called\r\n\r\nCopy Constructor called\r\n\r\nNormal Constructor called\r\n\r\nCopy Constructor called', 'Normal Constructor called\r\nCopy Constructor called\r\n\r\nCopy Constructor called\r\n\r\nNormal Constructor called\r\n\r\nCopy Constructor called', 'Normal Constructor called\r\nCopy Constructor called\r\n\r\nCopy Constructor called\r\n\r\nNormal Constructor called', 'Compile Error', 'C', 'See following comments for explanation: Point *t1, *t2;   // No constructor call t1 = new Point(10, 15);  // Normal constructor call t2 = new Point(*t1);   // Copy constructor call  Point t3 = *t1;  // Copy Constructor call Point t4;   // Normal Constructor call t4 = t3;   // Assignment operator call', 'A', 'D'),
(10, 'Assume that an integer and a pointer each takes 4 bytes. Also, assume that there is no alignment in objects. Predict the output following program.\r\n#include<iostream>\r\nusing namespace std;\r\n \r\nclass Test\r\n{\r\n    static int x;\r\n    int *ptr;\r\n    int y;\r\n};\r\n \r\nint main()\r\n{\r\n    Test t;\r\n    cout << sizeof(t) << " ";\r\n    cout << sizeof(Test *);\r\n}', '12 4', '8 4', '12 12', '8 8', 'B', 'For a compiler where pointers take 4 bytes, the statement "sizeof(Test *)" returns 4 (size of the pointer ptr). The statement "sizeof(t)" returns 8. Static is not associated with each object of the class.', 'A', 'C'),
(11, '#include <iostream>\r\nusing namespace std; \r\nclass A\r\n{\r\n    int id;\r\n    static int count;\r\npublic:\r\n    A() {\r\n        count++;\r\n        id = count;\r\n        cout << "constructor for id " << id << endl;\r\n    }\r\n    ~A() {\r\n        cout << "destructor for id " << id << endl;\r\n    }\r\n};\r\n  \r\nint A::count = 0;\r\n  \r\nint main() {\r\n    A a[3];\r\n    return 0;\r\n}', 'constructor for id 1\r\nconstructor for id 2\r\nconstructor for id 3\r\ndestructor for id 3\r\ndestructor for id 3\r\ndestructor for id 3', 'constructor for id 1\r\nconstructor for id 2\r\nconstructor for id 3\r\ndestructor for id 1\r\ndestructor for id 2\r\ndestructor for id 3', 'Compiler Dependent.', 'constructor for id 1\r\nconstructor for id 2\r\nconstructor for id 3\r\ndestructor for id 3\r\ndestructor for id 2\r\ndestructor for id 1', 'D', 'In the above program, id is a static variable and it is incremented with every object creation. Object a[0] is created first, but the object a[2] is destroyed first. Objects are always destroyed in reverse order of their creation. The reason for reverse order is, an object created later may use the previously created object.', 'A', 'C'),
(12, '#include<iostream>\r\nusing namespace std;\r\n \r\nclass Point {\r\nprivate:\r\n  int x, y;\r\npublic:\r\n  Point() : x(0), y(0) { }\r\n  Point& operator()(int dx, int dy);\r\n  void show() {cout << "x = " << x << ", y = " << y; }\r\n};\r\n \r\nPoint& Point::operator()(int dy, int dx)\r\n{\r\n    x = dx;\r\n    y = dy;\r\n    return *this;\r\n}\r\n \r\nint main()\r\n{\r\n  Point pt;\r\n  pt(3, 2);\r\n  pt.show();\r\n  return 0;\r\n}', 'x = 3, y = 2', 'x = 0, y = 0', 'x = 2, y = 3', 'Compiler Error', 'C', 'This a simple example of function call operator overloading. The function call operator, when overloaded, does not modify how functions are called. Rather, it modifies how the operator is to be interpreted when applied to objects of a given type. If you overload a function call operator for a class its declaration will have the following form:    return_type operator()(parameter_list)', 'B', 'D'),
(13, 'Which of the following overloaded functions are allowed in C++?', '1) Function declarations that differ only in the return type\r\n    int fun(int x, int y);\r\n         void fun(int x, int y);', '2) Functions that differ only by static keyword in return type\r\n    int fun(int x, int y);\r\n         static int fun(int x, int y);', '3)Parameter declarations that differ only in a pointer * versus an array []\r\nint fun(int *ptr, int n);\r\nint fun(int ptr[], int n);', 'None of the above', 'D', 'You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You can not overload function declarations that differ only by return type.', 'B', 'C'),
(14, '#include <iostream>\r\nclass Test\r\n{\r\npublic:\r\n    void fun();\r\n};\r\nstatic void Test::fun()   \r\n{\r\n    std::cout<<"fun() is static\n";\r\n}\r\nint main()\r\n{\r\n    Test::fun();   \r\n    return 0;\r\n}', 'fun() is static', 'Run-time Error', 'No Output', 'Compile Error', 'D', ' cannot call member function without object If the static function is to be defined outside the class then static keyword must be present in function declaration only not in the definition outside the class', 'A', 'C'),
(15, '#include<iostream>\r\nusing namespace std;\r\n\r\nstatic int a;\r\nint b;\r\nint main()\r\n{\r\n    static int c;\r\n    int d;\r\n    cout <<a << ","<< b<< ","<<c <<"," <<d;\r\n    return 0;\r\n}\r\n\r\nPredict the output of above code', '0,0,0,0', 'Garbage Value, Garbage Value, Garbage Value, Garbage Value', '0, Garbage Value, 0, Garbage Value', '0,0,0,Garbage Value', 'D', 'All global variables are initialised by 0', 'A', 'C'),
(16, 'class techtonics\r\n{\r\n\r\n};\r\n\r\nint main()\r\n{\r\n    cout<< sizeof(techtonics);\r\n    return 0;\r\n}', '', 'Garbage Value', '1', '-1', 'C', 'All classes are given size 1 by default by compiler. It is the sizeof its address..', 'A', 'D'),
(17, '\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int var = 010;\r\n    cout<< var;\r\n}\r\n\r\nPredict the output.\r\n\r\n', '2', '8', '9', '10', 'B', '010 = octal 8 starting anumer with 0 makes it octal', 'D', 'A'),
(18, '#include <stdio.h>\r\nint main()\r\n{\r\n        int i=43;\r\n        printf("%d\n",printf("%d",printf("%d",i)));\r\n        return 0;\r\n}\r\n\r\nPredict the output.', 'Compile Time Error', '434343', '43', '4321', 'D', 'i=i, is assigning member variable to itself.', 'A', 'B'),
(19, '#include <stdio.h>\r\n#define SQUARE(a) (a)*(a)\r\n\r\nint main() {\r\n    printf("%d\n", SQUARE(4));\r\n    int x = 3;\r\n    printf("%d\n", SQUARE(++x));\r\n}\r\n\r\nPredict the output', '"16\r\n12"\r\n', '"16\r\n16"\r\n', '"16\r\n9"\r\n', 'Output depends on compiler\r\n', 'D', 'Post increment and pre-increment depends on the compiler. Ideally Answer should be 16 16. But now you think what it can be', 'A', 'C'),
(20, '"#include<stdio.h>\r\nint main()\r\n{\r\n    int i = 10;\r\n    static int x = i;\r\n    if (x==i)\r\n        printf(""Yes"");\r\n    else\r\n        printf(""No"");\r\n    return 0;\r\n}\r\n\r\nPredict the output of above code."\r\n', 'Yes\r\n', 'No\r\n', 'Compile time error\r\n', 'Run time error\r\n', 'C', 'Static variables cannot be compared with normal variables', 'A', 'B'),
(21, '"Consider the function func shown below:\r\n\r\nint func(int num) \r\n{\r\n    int count = 0;\r\n    while (num) \r\n    {\r\n        count++;\r\n        num>>= 1;\r\n    }\r\n    return (count);\r\n}\r\n\r\nThe value returned by func(435)is __________."\r\n', '435', '9', '8\r\n', '7', 'B', 'Here >> is binary right-shift operator.  ', 'A', 'D'),
(22, '"#include<stdio.h>\r\nvoid mystery(int *ptra, int *ptrb)\r\n{\r\n    int *temp;\r\n    temp = ptrb;\r\n    ptrb = ptra;\r\n    ptra = temp;\r\n}\r\nint main()\r\n{\r\n    int a=2016, b=0, c=4, d=42;\r\n    mystery(&a, &b);\r\n    if (a < c)\r\n        mystery(&c, &a);\r\n    mystery(&a, &d);\r\n    printf(""%d\n"", a);\r\n}\r\nOutput of above code is?"\r\n', '2016\r\n', '0\r\n', '4\r\n', '42\r\n', 'A', 'Here function is called by reference', 'C', 'D'),
(23, '"#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    if(~5 == -6)\r\n        cout << ""Yes"";\r\n    else\r\n        cout << ""No"";\r\n}\r\n\r\nPredict the output."\r\n', 'Yes', 'No', 'Compile time error\r\n', 'Run time error\r\n', 'A', 'Here Tilde operator is used for bitwise NOT of the binary.', 'B', 'C'),
(24, 'Which of the following concept of oops allows compiler to insert arguments in a function call if it is not specified?\r\n', 'Call by value\r\n', 'Call by reference\r\n', 'Default arguments\r\n', 'Call By Pointer\r\n', 'C', 'Theory Question.', 'A', 'B'),
(25, 'What will be the output of the following program Class TEST { int n; public: TEST( ) { n=0; } int getval(){ return n; } int getval( ) const { return n+1; }  };  int main() {cout<<TEST.getval( );  return 0;   }\r\n', '', '1', '2', 'Syntax Error', 'D', 'Non-static functions cannot be called by using class name. We have to create an object.', 'A', 'B'),
(26, 'What is the output of the program #include<iostream.h> using namespace std;void show( ) {static int b=10; b++; cout<<b;} int main() { show(); show(); show(); return 0;} \r\n', '10  10  10\r\n', '10  11  12\r\n', '11  12  13 \r\n', 'syntax error\r\n', 'C', 'Static variables are initialised only once.', 'A', 'D'),
(27, 'The keyword friend does not appear in\r\n', 'The class allowing access to another class\r\n', 'The class desiring access to another class\r\n', 'The private section of a class\r\n', 'The public section of a class \r\n', 'C', 'Hehehehe. You have been tricked. You won''t get any hint for this question. ', 'A', 'B'),
(28, '"select the correct options\r\nI. when you overload<< operator then >> operator automatically get overload.\r\nII. You can overload uniary operator to work with the binary operator"\r\n', 'only I is true\r\n', 'neither I nor II are true\r\n', 'both are true\r\n', 'only II is true\r\n', 'B', 'When one operator is overloaded meaning  of that operator will change.', 'A', 'D'),
(29, 'The following is a valid statement in C++\r\n', ' int x=(int)2.50;\r\n', 'int x=int(2.50);\r\n', 'Both (a) & (b)\r\n', 'None of the above\r\n', 'C', 'Theory Question.', 'B', 'D'),
(30, 'What will be the output of the following program #include<iostream> using namespace std; class oomp{public:  int n;float m;  oomp( ) { n=0; m=0; } }; int main( ) {int x; oomp sub1; sub1.m=9.8; sub1.n=20; x=sub1.m+sub1.n; cout<<x;}\r\n', '20.9\r\n', '29.8\r\n', '20\r\n', '29\r\n', 'D', 'Here x is an integer so... floating point  is ignored.', 'A', 'C'),
(31, '"        #include <iostream>\r\n        using namespace std;\r\n        struct a\r\n        {\r\n            int count;\r\n        };\r\n        struct b\r\n        {\r\n            int* value;\r\n        };\r\n        struct c : public a, public b\r\n        {\r\n        };\r\n        int main()\r\n        {\r\n            c* p = new c;\r\n            p->value = 0;\r\n            cout << ""Inherited"";\r\n            return 0;\r\n        }"\r\n', 'inherited\r\n', 'error\r\n', 'runtime error\r\n', 'none of these\r\n', 'A', 'Inveritance can be implemented using struct also.', 'C', 'D'),
(32, ' To point to the address of any pointer variable cast the pointer to\r\n', 'char *', ' int *', ' void *', 'none of these', 'C', 'The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printing characters, in an implementation-defined manner. printf("The address of ptr is %p\n", (void *) &ptr)', 'A', 'D'),
(33, 'How do we declare an interface class?', 'By making all methods pure virtual in a class\r\n', 'By making all the methods in a class abstract, using abstract keyword', 'By declaring class as Interface class, using interface keyword', 'Not possible to create interface class in c++', 'A', 'Interface class have only declarations of method so that user can define it later.', 'C', 'D'),
(34, 'Predict the output.\n\nclass DemoClass\n{\npublic:\n    void display()\n    {\n        std::cout<<""\\nDisplay Function 1"";\n    }\n    void display() const\n    {\n        std::cout<<""\\nDisplay Function 2"";\n    }\n};\n\nint main()\n{\n    DemoClass obj;\n    obj.display();\n}\n', 'Display Function 1\n', 'Display Function 2', 'Compile Time error: error C2535: ''void DemoClass::display(void)'' : member function already defined or declared.', 'Run time error\n', 'A', '"Here, it would seem that, as ‘x’ and ‘i’ are equal, so the output will be “x and i are Equal”. But the output is quite unexpected.\nAs, static variables are load time entity while auto variables are run time entity an We can not initialize any load time variable by the run time variable. So,the output the c code above will show “Compile error”."\n', 'B', 'D'),
(35, '#include <stdio.h>\nint main()\n{\n    int i;\n    i = 10;\n    printf(""%d\\n"",i);\n    printf(""%d\\n"", sizeof(i++));\n    printf(""%d\\n"",i);\n    return 0;\n}\n\nPredict the output. (Consider size of int=4 bytes)\n', 'Compile Time Error', '10 4 11', '10 5 11', '10 4 10', 'D', 'The expression in a sizeof is not evaluated because sizeof is not a function, but a compile-time operator. Only its operand''s type is used to determine size. The sizeof(i++) expresion is then replaced by a constant, so there is no "++" at run-time.\n', 'B', 'C'),
(36, 'What is the output of the program #include<iostream.h> using namespace std;void show( ) {static int b=10; b++; cout<<b;} int main() { show(); show(); show(); return 0;} \r\n', '0', 'error : positive value required', 'compilation error', 'None', 'A', ' If variable has arithmetic type, it is initialized to (positive or unsigned) zero.', 'B', 'D'),
(37, 'Choose most appropriate statement ', 'An abstract base class can have pure virtual destructor', 'An abstract base class can have only virtual destructor', 'An abstract base class can have non virtual destructor', 'An abstract base class cannot have destructor', 'D', 'The destructor is the only method that even if it is pure virtual has to have an implementation in order to instantiate derived classes.', 'A', 'B'),
(38, 'What happen on execution of the following code\nclass base { \n//code\n};\nclass derived:protected base {\n//code\n};\n', 'Protected members of base class will come under protected of derived class ', 'Private and Protected members of base class will come under protected of derived class ', 'Public and Protected members of base class will come under protected of derived class ', 'Public and Protected members of base class will come under public of derived class ', 'C', 'Private members of base class always remain pivate even after inheritance. Although Public and Protected members will come under protected of derived class.', 'A', 'B');

-- --------------------------------------------------------

--
-- Table structure for table `participant_info`
--

CREATE TABLE `participant_info` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) NOT NULL,
  `sname` varchar(30) NOT NULL,
  `phone1` char(10) NOT NULL,
  `phone2` char(10) NOT NULL,
  `femail` varchar(60) NOT NULL,
  `semail` varchar(60) NOT NULL,
  `password` varchar(15) NOT NULL,
  `score` int(3) NOT NULL DEFAULT '0',
  `easy_solved` tinyint(4) NOT NULL DEFAULT '0',
  `inter_solved` tinyint(4) NOT NULL DEFAULT '0',
  `hard_solved` tinyint(4) NOT NULL DEFAULT '0',
  `current_easy_pointer` tinyint(4) NOT NULL DEFAULT '1',
  `current_intermediate_pointer` tinyint(4) NOT NULL DEFAULT '1',
  `current_hard_pointer` tinyint(4) NOT NULL DEFAULT '1'
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `participant_info`
--

INSERT INTO `participant_info` (`id`, `fname`, `sname`, `phone1`, `phone2`, `femail`, `semail`, `password`, `score`, `easy_solved`, `inter_solved`, `hard_solved`, `current_easy_pointer`, `current_intermediate_pointer`, `current_hard_pointer`) VALUES
(2, 'Priya Bhangale', 'Sameer Bhangele', '45678765', '', 's@gmail.com', 'p@gmail.com', '123', 325, 0, 0, 0, 0, 0, 0),
(3, 'Amol Sanger', 'Bayes Akshay', '4567644655', '', 'a@gmail.com', 'b@gmail.com', '123', 350, 0, 0, 0, 0, 0, 0),
(4, 'Amol Rade', 'Neha Tade', '9999090655', '', 'f@gmail.com', 'y@gmail.com', '123', 323, 0, 0, 0, 0, 0, 0);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `easy`
--
ALTER TABLE `easy`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `hard`
--
ALTER TABLE `hard`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `intermediate`
--
ALTER TABLE `intermediate`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `participant_info`
--
ALTER TABLE `participant_info`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `femail` (`femail`),
  ADD UNIQUE KEY `phone` (`phone1`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `easy`
--
ALTER TABLE `easy`
  MODIFY `id` tinyint(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=52;
--
-- AUTO_INCREMENT for table `hard`
--
ALTER TABLE `hard`
  MODIFY `id` tinyint(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=37;
--
-- AUTO_INCREMENT for table `intermediate`
--
ALTER TABLE `intermediate`
  MODIFY `id` tinyint(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=39;
--
-- AUTO_INCREMENT for table `participant_info`
--
ALTER TABLE `participant_info`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
